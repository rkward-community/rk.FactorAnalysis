# the plugin code was generated by this script
# you should not change the plugin code directly, but this script
# note: this script only creates objects in your workspace,
# *EXCEPT* for the last call, see below.

require(rkwarddev)
rkwarddev.required("0.08-2")

local({
# set the output directory to overwrite the actual plugin
output.dir <- tempdir()
overwrite <- TRUE
# if you set guess.getters to TRUE, the resulting code will need RKWard >= 0.6.0
guess.getter <- TRUE
rk.set.indent(by="  ")
rk.set.empty.e(TRUE)
update.translations <- TRUE

about.info <- rk.XML.about(
  name="rk.FactorAnalysis",
  author=c(
    person(given="Meik", family="Michalke",
      email="meik.michalke@hhu.de", role=c("aut","cre"))),
  about=list(desc="RKWard GUI to conduct principal component and factor analysis",
    version="0.01-15", url="https://rkward.kde.org", long.desc="RKWard GUI to conduct principal component and factor analysis (using the psych package). Also includes dialogs for scree plots, correlation plots, VSS/MAP and parallel analysis.")
  )
dependencies.info <- rk.XML.dependencies(
  dependencies=list(rkward.min=ifelse(isTRUE(guess.getter), "0.6.0", "0.5.6")),
  package=list(c(name="psych", min="1.1.10"))
)


#############
## principal component & factor analysis
#############
# using principal()/fa() of the package 'psych'

factorMethod <- rk.XML.radio("Factoring method",
  options=list(
    "Principal component analysis"=c(val="PCA"),
    "Exploratory factor analysis"=c(val="EFA", chk=TRUE)
  ),
  id.name="factorMethod"
)
corrMethod <- rk.XML.radio("Correlation method",
  options=list(
    "Pearson product-moment (numeric data)"=c(val="fa", chk=TRUE),
    "Polychoric (polytomous data)"=c(val="fa.poly")
  ),
  id.name="corrMethod"
)
data <- rk.XML.varselector(label="Select data", id.name="data")
dataSelected <- rk.XML.varslot(label="Correlation matrix (or raw data matrix)", source=data, required=TRUE, id.name="dataSelected")

saveResults <- rk.XML.saveobj("Save results to workspace", initial="FA.results", id.name="saveResults")

rotationMethodPCA <- rk.XML.dropdown("Rotation method",
  options=list(
    "none"=c(val="none"),
    "varimax (orthogonal)"=c(val="varimax", chk=TRUE),
    "quatimax (orthogonal)"=c(val="quatimax"),
    "promax"=c(val="promax"),
    "oblimin"=c(val="oblimin"),
    "simplimax"=c(val="simplimax"),
    "cluster"=c(val="cluster")
  ),
  id.name="rotationMethodPCA"
)
rotationMethodEFA <- rk.XML.dropdown("Rotation method",
  options=list(
    "None"=c(val="none"),
    "Varimax (orthogonal)"=c(val="varimax"),
    "Quatimax (orthogonal)"=c(val="quatimax"),
    "BentlerT (orthogonal)"=c(val="bentlerT"),
    "GeominT (orthogonal)"=c(val="geominT"),
    "Bifactor (orthogonal)"=c(val="bifactor"),
    "Promax"=c(val="promax"),
    "Oblimin"=c(val="oblimin", chk=TRUE),
    "Simplimax"=c(val="simplimax"),
    "BentlerQ"=c(val="bentlerQ"),
    "GeominQ"=c(val="geominQ"),
    "Biquartimin"=c(val="biquartimin"),
    "Cluster"=c(val="cluster")
  ),
  id.name="rotationMethodEFA"
)

factorMethodEFA <- rk.XML.dropdown("Factoring method",
  options=list(
    "Minimum residual (ULS)"=c(val="minres", chk=TRUE),
    "Weighted least squares (WLS)"=c(val="wls"),
    "Generalized weighted least squares (GLS)"=c(val="gls"),
    "Principal axis"=c(val="pa"),
    "Maximum likelihood"=c(val="ml")
  ),
  id.name="factorMethodEFA"
)

initCommunalityEst <- rk.XML.radio("Initial communality estimate",
  options=list(
    "Squared multiple correlations"=c(val="true", chk=TRUE),
    "1"=c(val="false")
  ),
  id.name="initCommunalityEst"
)
matrixToFactor <- rk.XML.radio("Matrix to factor",
  options=list(
    "Factor correlation matrix"=c(val="false", chk=TRUE),
    "Factor covariance matrix"=c(val="true")
  ),
  id.name="matrixToFactor"
)
matrixToScore <- rk.XML.radio("Matrix to score",
  options=list(
    "Scores based on structure matrix (oblique)"=c(val="true", chk=TRUE),
    "Scores based on pattern matrix"=c(val="false")
  ),
  id.name="matrixToScore"
)

# common options
numFactors <- rk.XML.spinbox("Number of factors to extract", min=1, initial=1, real=FALSE, id.name="numFactors")
cutoff <- rk.XML.spinbox("Marker item threshold (cut-off)", initial=0.1, id.name="cutoff")
showDecimals <- rk.XML.spinbox("Show decimals", min=0, initial=3, max=20, real=FALSE, id.name="showDecimals")

showResiduals <- rk.XML.cbox("Show residuals", value="true", id.name="showResiduals")
kaiser <- rk.XML.cbox("Apply Kaiser normalization", id.name="kaiser")

factorScoreMethod <- rk.XML.dropdown("Method to find factor scores",
  options=list(
    "Regression"=c(val="regression", chk=TRUE),
    "Simple regression (Thurstone)"=c(val="Thurstone"),
    "correlation preserving (ten Berge)"=c(val="tenBerge"),
    "Anderson"=c(val="Anderson"),
    "Bartlett"=c(val="Bartlett")
  ),
  id.name="factorScoreMethod"
)
missingsPCA <- rk.XML.dropdown("Dealing with missing values",
  options=list(
    "Don't impute missing values"=c(val="none", chk=TRUE),
    "Replace with median"=c(val="median"),
    "Replace with mean"=c(val="mean")
  ),
  id.name="missingsPCA"
)
missingsEFA <- rk.XML.dropdown("Dealing with missing values",
  options=list(
    "Don't impute missing values"=c(val="none", chk=TRUE),
    "Replace with median"=c(val="median"),
    "Replace with mean"=c(val="mean")
  ),
  id.name="missingsEFA"
)
componentScores <- rk.XML.frame(missingsPCA, label="Find component scores", checkable=TRUE, chk=FALSE, id.name="componentScores")
numObs <- rk.XML.spinbox("Number of observations to find the correlation matrix (GoF statistics)",
  min=0,
  initial=0,
  real=FALSE,
  id.name="numObs"
)

numIter <- rk.XML.spinbox("Number of iterations", min=2, initial=2, real=FALSE, id.name="numIter")
minErr <- rk.XML.spinbox("Until change in communalities is less than", min=0.0001, initial=0.001, id.name="minErr")
maxIter <- rk.XML.spinbox("Maximum number of iterations", min=2, initial=50, real=FALSE, id.name="maxIter")
iterate <- rk.XML.frame(
  rk.XML.row(
    rk.XML.col(numIter),
    rk.XML.col(minErr),
    rk.XML.col(maxIter)
  ),
  label="Perform bootstrap iterations",
  checkable=TRUE,
  chk=FALSE,
  id.name="iterate"
)

tab1.data <- rk.XML.row(
    data,
    rk.XML.col(
      rk.XML.frame(dataSelected),
      rk.XML.frame(factorMethod),
      rk.XML.frame(corrMethod),
      numFactors,
      rk.XML.stretch(),
      saveResults
    )
  )

tab2.options <- rk.XML.row(
    rk.XML.col(
      rk.XML.row(
        rk.XML.col(
          rotationMethodPCA,
          rotationMethodEFA
        ),
        rk.XML.col(
          factorMethodEFA
        )
      ),
      rk.XML.row(
        rk.XML.col(initCommunalityEst),
        rk.XML.col(matrixToFactor),
        rk.XML.col(matrixToScore)
      ),
      rk.XML.frame(
        rk.XML.row(
          rk.XML.col(showResiduals),
          rk.XML.col(kaiser)
        )
      ),
      componentScores,
      rk.XML.row(
        rk.XML.col(factorScoreMethod),
        rk.XML.col(missingsEFA)
      ),
       numObs,
      iterate,
       rk.XML.stretch(),
      rk.XML.frame(
        rk.XML.row(
          rk.XML.col(cutoff),
          rk.XML.col(showDecimals)
        ),
      label="Output")
    ), id.name="row_cPCAREFARNmain"
   )

full.dialog <- rk.XML.dialog(rk.XML.tabbook(label="Factor analysis",
    tabs=list("Data"=tab1.data, "Options"=tab2.options)
  ), label="Factor analysis")

## logic section
  lgc.sect <- rk.XML.logic(
    FA.gov.analysis <- rk.XML.convert(sources=list(string=factorMethod), mode=c(equals="PCA")),
    FA.gov.corr <- rk.XML.convert(sources=list(string=corrMethod), mode=c(equals="fa")),
    FA.gov.fa <- rk.XML.convert(sources=list(not=FA.gov.analysis, FA.gov.corr), mode=c(and=""), id.name="lgc_lgcFPCACfa"),
    FA.gov.notpoly <- rk.XML.convert(sources=list(FA.gov.analysis, FA.gov.corr), mode=c(or=""), id.name="lgc_lgcFPCACnp"),
    rk.XML.connect(governor=FA.gov.analysis, client=rotationMethodPCA, set="visible"),
    rk.XML.connect(governor=FA.gov.analysis, client=rotationMethodEFA, set="visible", not=TRUE),
    rk.XML.connect(governor=FA.gov.analysis, client=factorMethodEFA, set="enabled", not=TRUE),
    rk.XML.connect(governor=FA.gov.analysis, client=initCommunalityEst, set="enabled", not=TRUE),
    rk.XML.connect(governor=FA.gov.fa, client=matrixToFactor, set="enabled"),
    rk.XML.connect(governor=FA.gov.notpoly, client=showResiduals, set="enabled"),
    rk.XML.connect(governor=FA.gov.analysis, client=matrixToScore, set="enabled", not=TRUE),
    rk.XML.connect(governor=FA.gov.analysis, client=componentScores, set="visible"),
    rk.XML.connect(governor=FA.gov.analysis, client=factorScoreMethod, set="visible", not=TRUE),
    rk.XML.connect(governor=FA.gov.fa, client=factorScoreMethod, set="enabled"),
    rk.XML.connect(governor=FA.gov.analysis, client=missingsEFA, set="visible", not=TRUE),
    rk.XML.connect(governor=FA.gov.analysis, client=iterate, set="enabled", not=TRUE),
    rk.XML.connect(governor=FA.gov.analysis, client=corrMethod, set="enabled", not=TRUE)
)

## JavaScript
# discard this object later, we just need the name...
js.frm.score <- rk.JS.vars(componentScores, modifiers="checked")
js.frm.iterate <- rk.JS.vars(iterate, modifiers="checked")

js.calc <- rk.paste.JS(
  # create a variable for oblique transformations
  "var obrot = new Array(\"promax\", \"oblimin\", \"simplimax\", \"bentlerQ\", \"geominQ\", \"biquartimin\", \"cluster\");\n",
  js(
    if(id("(obrot.indexOf(",rotationMethodEFA ,") == -1 && ", factorMethod,
    " != \"PCA\") | (obrot.indexOf(", rotationMethodPCA ,") == -1 && ", factorMethod,
    " == \"PCA\")")){
      "isObrot = false;"
    } else {
      "isObrot = true;"
    }
  ),
  echo("\tFA.results <- "),
  js(
    if(factorMethod == "PCA"){
      echo("principal(")
    } else if(kaiser){
      echo("kaiser(", corrMethod, "(")
    } else {
      echo(corrMethod, "(")
    },
    if(dataSelected){ 
      if(factorMethod == "EFA" && corrMethod == "fa.poly"){
        echo("x=", dataSelected)
      } else {
        echo("r=", dataSelected)
      }
    } else {},
    if(numFactors > 1){
      echo(",\n\t\tnfactors=", numFactors)
    } else {},
    if((factorMethod == "PCA" || corrMethod == "fa") && showResiduals){
      echo(",\n\t\tresiduals=TRUE")
    } else {},
    if(factorMethod == "PCA"){
      echo(",\n\t\trotate=\"", rotationMethodPCA, "\"")
    } else {
      if(kaiser){
        echo(",\n\t\trotate=\"none\"")
      } else {
        echo(",\n\t\trotate=\"", rotationMethodEFA, "\"")
      }
    },
    if(numObs > 0){
      echo(",\n\t\tn.obs=", numObs)
    } else {},
    if(factorMethod == "PCA"){
      if(js.frm.score){
        echo(",\n\t\tscores=TRUE")
      } else {}
      if(js.frm.score && missingsPCA != "none"){
        echo(",\n\t\tmissing=TRUE,\n\t\timpute=\"", missingsPCA, "\"")
      } else {}
    } else {
      if(js.frm.iterate){
        echo(",\n\t\tn.iter=", numIter)
      } else {}
      if(corrMethod == "fa"){
        echo(",\n\t\tscores=\"", factorScoreMethod, "\"")
      } else {}
      if(initCommunalityEst == "false"){
        echo(",\n\t\tSMC=FALSE")
      } else {}
      if(corrMethod == "fa" && matrixToFactor == "true"){
        echo(",\n\t\tcovar=TRUE")
      } else {}
      if(missingsEFA != "none"){
        echo(",\n\t\tmissing=TRUE,\n\t\timpute=\"", missingsEFA, "\"")
      } else {}
      if(js.frm.iterate && minErr != 0.001){
        echo(",\n\t\tmin.err=", minErr)
      } else {}
      if(js.frm.iterate && maxIter != 50){
        echo(",\n\t\tmax.iter=", maxIter)
      } else {}
      echo(",\n\t\tfm=\"", factorMethodEFA, "\"")
      if(matrixToScore == "false"){
        echo(",\n\t\toblique.scores=FALSE")
      } else {}
    },
    if(factorMethod == "EFA" && kaiser){
      echo("), rotate=\"", rotationMethodEFA, "\"")
    } else {}
  ),
  echo(")\n\n")
)

js.print <- rk.paste.JS(
  rk.JS.vars(factorMethod, numFactors, rotationMethodPCA, factorMethodEFA, rotationMethodEFA,
    kaiser, showDecimals, cutoff),
  echo("\tdigits <- function(obj) {
    return(format(round(obj, digits=", showDecimals, "), nsmall=", showDecimals, "))
  }\n"),
  R.comment("Make matrix from loadings, for more flexible output"),
  echo("\tFA.load.dim <- dim(FA.results$loadings)
  FA.load.names <- dimnames(FA.results$loadings)\n"),
  R.comment("Nicen component names"),
  echo("\tFA.load.names[[2]] <- paste("),
  js(
    if(factorMethod == "PCA"){
      echo("\"Component\"")
    } else {
      echo("\"Factor\"")
    }
  ),
  echo(", 1:length(FA.load.names[[2]]))
  FA.load <- FA.results$loadings[!is.character(FA.results$loadings)]
  FA.load.mtx <- matrix(FA.load, nrow=FA.load.dim[1], dimnames=FA.load.names)\n"),
  R.comment("For printout, highlight loadings"),
  echo("\tidx.load <- abs(FA.load) >= ", cutoff, "
  FA.load.print <- digits(FA.load)
  FA.load.print[idx.load] <- paste(\"<b>\", FA.load.print[idx.load], \"</b>\", sep=\"\")
  FA.load.print <- matrix(FA.load.print, nrow=FA.load.dim[1], dimnames=FA.load.names)\n"),
  R.comment("Append communality and uniqueness"),
  echo("\tFA.load.print <- cbind(FA.load.print,\n\t\t",
    i18n("communality"), "=paste(\"<span style=\\\"color:grey;\\\">\", digits(FA.results$communality), \"</span>\", sep=\"\"),\n\t\t",
    i18n("uniqueness"), "=paste(\"<span style=\\\"color:grey;\\\">\", digits(FA.results$uniquenesses), \"</span>\", sep=\"\"))\n"),
  R.comment("Append sum of squared loadings"),
  js(
    if("isObrot"){
      echo("\tFA.s2load <- diag(FA.results$Phi %*% t(FA.results$loadings) %*% FA.results$loadings)\n")
    } else {
      echo("\tFA.s2load <- colSums(FA.results$loadings^2)\n")
    }
  ),
  R.comment("Variance explained"),
  echo("\tFA.varExp <- 100 * FA.s2load / FA.load.dim[1]
  FA.load.print <- rbind(FA.load.print,\n\t\t",
    i18n("Sum of squared loadings"), "=c(paste(\"<span style=\\\"color:grey;\\\">\", digits(FA.s2load), \"</span>\", sep=\"\"),
    digits(sum(FA.s2load)), \"\"),\n\t\t",
    i18n("Variance explained (%)"), "=c(paste(\"<span style=\\\"color:grey;\\\">\", digits(FA.varExp), \"</span>\", sep=\"\"), \"\", \"\"),\n\t\t",
    i18n("Variance explained (cum %)"), "=c(paste(\"<span style=\\\"color:grey;\\\">\", digits(cumsum(FA.varExp)), \"</span>\", sep=\"\"), \"\", \"\"))\n"),
  R.comment("Finally, make it a data.frame"),
  echo("\tFA.load.print <- data.frame(FA.load.print, stringsAsFactors=FALSE)\n"),
  js(
    if("isObrot"){
      R.comment("Prepare correlation matrix for printout")
      echo("\tcomp.corr <- digits(FA.results$Phi)
  dimnames(comp.corr) <- list(FA.load.names[[2]],FA.load.names[[2]])\n")
    } else {}
  ),
  R.comment("Prepare score*factors matrix for printout"),
  echo("\tscfc.corr <- data.frame(rbind(\n\t\t",
    i18n("Correlation of scores with factors"), "=digits(sqrt(FA.results$R2)),\n\t\t",
    i18n("Multiple R square of scores with factors"), "=digits(FA.results$R2),\n\t\t",
    i18n("Minimum correlation of possible factor scores"), "=digits((2*FA.results$R2)-1)), stringsAsFactors=FALSE)
  colnames(scfc.corr) <- FA.load.names[[2]]\n\n"),
  R.comment("Ok, here the actual output starts", level=1),
  js(
    if(factorMethod == "PCA"){
      echo("rk.header (", i18n("Principal Component Analysis"))
    } else {
      echo("rk.header (", i18n("Factor Analysis"))
    }
  ),
  echo(",\n\tparameters=list(\n"),
  js(
    if(factorMethod == "PCA"){
      echo(
        "\t\t", i18n("Number of components"), "=", numFactors, ",\n",
        "\t\t", i18n("Rotation"), "=\"", rotationMethodPCA, "\""
      )
    } else {
      echo(
        "\t\t", i18n("Number of factors"), "=", numFactors, ",\n",
        "\t\t", i18n("Factoring method"), "=\"", factorMethodEFA,"\",\n",
        "\t\t", i18n("Rotation"), "=\"", rotationMethodEFA, "\""
      )
      if(kaiser){
        echo(",\n\t\t", i18n("Normalization"), "=\"Kaiser\"")
      } else {}
    }
  ),
  echo("))\n"), # end rk.header()
  echo(
    "rk.results (list(\n\t",
    i18n("Degrees of freedom"), "=FA.results$dof,\n\t",
    i18n("Fit"), "=digits(FA.results$fit),\n\t",
    i18n("Fit (off diag)"), "=digits(FA.results$fit.off)\n\t))\n"
  ),
  rk.JS.header("Loadings", level=4),
  echo("rk.results (FA.load.print)\n"),
  js(
    if("isObrot"){
      rk.JS.header("Factor correlations", level=4)
      echo("rk.results (data.frame(comp.corr, stringsAsFactors=FALSE))\n")
    } else {}
  ),
#  echo("rk.header(\"Test of the hypothesis that ", numFactors, " factors are sufficient\", level=4)\n"),
  rk.JS.header("Measures of factor score adequacy", level=4),
  echo("rk.results (scfc.corr)\n")
)

############
## scree plot
############
screeData <- rk.XML.varselector(label="Select data.frame", id.name="screeData")
screeDataSelected <- rk.XML.varslot(label="Data", source=screeData, required=TRUE, id.name="screeDataSelected")

screeType <- rk.XML.radio(label="Draw scree for",
  options=list(
    "Factors and components"=c(val="both"),
    "Factors only"=c(val="fact"),
    "Prinicipal components only"=c(val="comp")
  ),
  id.name="screeType"
)

mainTitle <- rk.XML.input(label="Main title", initial="Scree plot", id.name="mainTitle")

horizLine <- rk.XML.frame(
  eigenvalue <- rk.XML.spinbox(
    label="Eigenvalue",
    min=0,
    initial=1,
    id.name="eigenvalue"
  ),
  checkable=TRUE,
  chk=TRUE,
  label="Horizontal line",
  id.name="horizLine"
)

scree.preview <- rk.XML.preview()

scree.full.dialog <- rk.XML.dialog(
  rk.XML.row(
    screeData,
    rk.XML.col(
      screeDataSelected,
      mainTitle,
      screeType,
      horizLine,
      rk.XML.stretch(),
      scree.preview
#       rk.XML.frame(var.dv, var.wid),
#       rk.XML.frame(var.within, var.between)
    )
  )
, label="Scree plot")

## JavaScript
scree.js.print <- rk.paste.JS(
  scree.chk.hline <- rk.JS.vars(horizLine, modifiers="checked"),
  rk.paste.JS.graph(
    echo("\t\tscree("),
    js(
      if(screeDataSelected){
        echo("\n\t\t\t", screeDataSelected)
      } else {},
      if(screeType == "comp"){
        echo(",\n\t\t\tfactors=FALSE")
      } else {},
      if(screeType == "fact"){
        echo(",\n\t\t\tpc=FALSE")
      } else {},
      if(mainTitle != "Scree plot"){
        echo(",\n\t\t\tmain=\"", mainTitle, "\"")
      } else {},
      if(scree.chk.hline){
        if(eigenvalue != 1){
          echo(",\n\t\t\thline=", eigenvalue)
        } else {}
      } else {
        echo(",\n\t\t\thline=-1")
      }
    ),
    echo(")")
  )
)

## make a whole component
scree.component <- rk.plugin.component("Scree plot",
  xml=list(
    dialog=scree.full.dialog
  ),
  js=list(
    require="psych",
    printout=scree.js.print
  ),
  guess.getter=guess.getter,
  hierarchy=list("analysis", "Factor analysis","Number of factors"),
  create=c("xml", "js")
)


############
## Horn's parallel analysis
############
hornData <- rk.XML.varselector(label="Select data.frame/matrix", id.name="hornData")
hornDataSelected <- rk.XML.varslot(label="Data", source=hornData, required=TRUE, id.name="hornDataSelected")

# minres, ml, uls, wls, gls, pa
hornFactorMethod <- rk.XML.dropdown("Factoring method",
  options=list(
    "Minimum residual (ULS)"=c(val="minres", chk=TRUE),
    "Weighted least squares (WLS)"=c(val="wls"),
    "Generalized weighted least squares (GLS)"=c(val="gls"),
    "Principal axis"=c(val="pa"),
    "Maximum likelihood"=c(val="ml")
  ),
  id.name="hornFactorMethod"
)


eigenvalueType <- rk.XML.radio(label="Show Eigenvalues for",
  options=list(
    "Factors and components"=c(val="both"),
    "Factors only"=c(val="fa"),
    "Prinicipal components only"=c(val="pc")
  ),
  id.name="eigenvalueType"
)

hornMainTitle <- rk.XML.input(label="Main title", initial="Parallel Analysis Scree Plots", id.name="hornMainTitle")
# prll.ylabel <- rk.XML.input(label="Y axis", initial="Eigen values of factors and components")

hornNumObs <- rk.XML.spinbox("Number of observations (0 implies raw data)", min=0, initial=0, real=FALSE, id.name="hornNumObs")

hornNumIter <- rk.XML.spinbox("Number of iterations", min=2, initial=20, real=FALSE, id.name="hornNumIter")

SMCs <- rk.XML.cbox("Estimate communalities by SMCs", id.name="SMCs")

errorBars <- rk.XML.cbox("Plot error bars", id.name="errorBars")

showLegend <- rk.XML.cbox("Show legend", chk=TRUE, id.name="showLegend")

prll.preview <- rk.XML.preview()

hornSaveResults <- rk.XML.saveobj("Save data to workspace", initial="parallel.data", id.name="hornSaveResults")


prll.full.dialog <- rk.XML.dialog(
  rk.XML.row(
    hornData,
    rk.XML.col(
      hornDataSelected,
      hornMainTitle,
      eigenvalueType,
      hornFactorMethod,
      hornNumObs,
      hornNumIter,
      SMCs,
      errorBars,
      showLegend,
      rk.XML.stretch(),
      hornSaveResults,
      prll.preview
    )
  )
, label="Parallel analysis")

## JavaScript
prll.js.print <- rk.paste.JS.graph(
  echo("\t\tparallel.data <- fa.parallel("),
  js(
    if(hornDataSelected){
      echo("\n\t\t\t", hornDataSelected)
    } else {},
    if(hornNumObs != 0){
      echo(",\n\t\t\tn.obs=", hornNumObs) # NULL
    } else {},
    if(hornFactorMethod != "minres"){
      echo(",\n\t\t\tfm=\"", hornFactorMethod, "\"")
    } else {},
    if(eigenvalueType != "both"){
      echo(",\n\t\t\tfa=\"", eigenvalueType, "\"")
    } else {},
    if(hornMainTitle != "Parallel Analysis Scree Plots"){
      echo(",\n\t\t\tmain=\"", hornMainTitle, "\"")
    } else {},
    if(hornNumIter != 20){
      echo(",\n\t\t\tn.iter=", hornNumIter)
    } else {}
  ),
  tf(errorBars, opt="error.bars", level=4), # FALSE
  tf(SMCs, opt="SMC", level=4), # FALSE
  # prll.ylabel # NULL
  tf(showLegend, opt="show.legend", true=FALSE, not=TRUE, level=4), # TRUE
  echo(")")
)

## make a whole component
prll.component <- rk.plugin.component("Parallel analysis (Horn)",
  xml=list(
    dialog=prll.full.dialog),
  js=list(
    require="psych",
    printout=prll.js.print),
  guess.getter=guess.getter,
  hierarchy=list("analysis", "Factor analysis","Number of factors"),
  create=c("xml", "js"))

############
## VSS & MAP
############
# vss(x, n = 8, rotate = "varimax", diagonal = FALSE, fm = "minres", n.obs=NULL,plot=TRUE,title="Very Simple Structure",...)

vssData <- rk.XML.varselector(label="Select data.frame/matrix", id.name="vssData")
vssDataSelected <- rk.XML.varslot(label="Data", source=vssData, required=TRUE, id.name="vssDataSelected")

# minres, ml, uls, wls, gls, pa
vssFactorMethod <- rk.XML.dropdown("Factoring method",
  options=list(
    "Minimum residual factoring (ULS)"=c(val="minres", chk=TRUE),
    "Principal component analysis"=c(val="pc"),
    "Principal axis factor analysis"=c(val="pa"),
    "Maximum likelihood factor analysis"=c(val="ml")
  ),
  id.name="vssFactorMethod"
)

vssRotate <- rk.XML.dropdown("Rotation method",
  options=list(
    "None"=c(val="none"),
    "Varimax (orthogonal)"=c(val="varimax", chk=TRUE),
    "Promax"=c(val="promax"),
    "Oblimin"=c(val="oblimin")
  ),
  id.name="vssRotate"
)

vssNumFactors <- rk.XML.spinbox("Number of factors to extract", min=1, initial=8, real=FALSE, id.name="vssNumFactors")

vssMainTitle <- rk.XML.input(label="Main title", initial="Very Simple Structure", id.name="vssMainTitle")

vssNumObs <- rk.XML.spinbox("Number of observations", min=0, initial=1000, real=FALSE, id.name="vssNumObs")

fitDiag <- rk.XML.cbox("Fit the diagonal as well", id.name="fitDiag")

# plot options
connectDiffCplx <- rk.XML.cbox("Connect different complexities", id.name="connectDiffCplx")
vss.preview <- rk.XML.preview()
vssPlotResults <- rk.XML.frame(
  vssMainTitle,
  connectDiffCplx,
  vss.preview,
  label="Plot results",
  checkable=TRUE,
  id.name="vssPlotResults"
)

vssSaveResults <- rk.XML.saveobj("Save data to workspace", initial="VSS.data", id.name="vssSaveResults")

vss.full.dialog <- rk.XML.dialog(
  rk.XML.row(
    vssData,
    rk.XML.col(
      vssDataSelected,
      vssFactorMethod,
      vssNumObs,
      vssRotate,
      fitDiag,
      rk.XML.stretch(),
      vssPlotResults,
      vssSaveResults
    )
  )
, label="VSS/MAP")

## logic section
  vss.lgc.sect <- rk.XML.logic(
    vss.gov.factmeth <- rk.XML.convert(sources=list(string=vssFactorMethod), mode=c(equals="ml")),
    rk.XML.connect(governor=vss.gov.factmeth, client=vssNumObs, set="enabled")
  )

## JavaScript
vss.js.calc <- rk.paste.JS(
  echo("\t\tVSS.data <- VSS("),
  js(
    if(vssDataSelected){
      echo("\n\t\t\t", vssDataSelected)
    } else {},
    if(vssFactorMethod == "ml" && vssNumObs != 0){
      echo(",\n\t\t\tn.obs=", vssNumObs) # NULL
    } else {},
    if(vssFactorMethod != "minres"){
      echo(",\n\t\t\tfm=\"", vssFactorMethod, "\"")
    } else {},
    if(vssRotate != "varimax"){
      echo(",\n\t\t\trotate=\"", vssRotate, "\"")
    } else {}
  ),
  tf(fitDiag, opt="diagonal", level=4), # FALSE
  echo(",\n\t\t\tplot=FALSE)\n"),
  echo("\n\t\tvss.stat.vars <- c(\"dof\",\"chisq\",\"prob\",\"sqresid\",\"fit\",\"cfit.1\",\"cfit.2\")\n",
  "\n\t\tvss.stat.results <- as.data.frame(cbind(Factors=1:length(VSS.data[[\"map\"]]), MAP=VSS.data[[\"map\"]], VSS.data[[\"vss.stats\"]][,vss.stat.vars]))\n",
  "\t\tcolnames(vss.stat.results)[3:9] <- paste(\"VSS\", vss.stat.vars, sep=\".\")\n\n",
  "\t\tmin.MAP <- which.min(VSS.data[[\"map\"]])\n",
  "\t\tmin.VSS1 <- which.min(VSS.data[[\"cfit.1\"]])\n",
  "\t\tmin.VSS2 <- which.min(VSS.data[[\"cfit.2\"]])\n\n")
)

vss.js.print <- rk.paste.JS(
  vss.js.frame.plot <- rk.JS.vars(vssPlotResults, modifiers="checked"),
#    echo("rk.print(VSS.data[[\"call\"]])\n"),
  js(
    if(vss.js.frame.plot){
      rk.paste.JS.graph(
        echo("\t\tVSS.plot(VSS.data"),
        js(
          if(vssMainTitle != "Very Simple Structure"){
            echo(",\n\t\t\ttitle=\"", vssMainTitle, "\"")
          } else {},
          if(connectDiffCplx){
            echo(",\n\t\t\tline=TRUE")
          } else {}
        ),
        echo(")\n")
      )
    } else {}
  ),
  rk.JS.header("Very Simple Structure", level=4),
  echo(
    "rk.print(paste(", i18n("VSS complexity 1 achieves a maximimum of "), ", round(VSS.data[[\"cfit.1\"]][min.VSS1], digits=3), ", i18n(" with "), ", min.VSS1, ", i18n(" factors."), ", sep=\"\"))\n",
    "rk.print(paste(", i18n("VSS complexity 2 achieves a maximimum of "), ", round(VSS.data[[\"cfit.2\"]][min.VSS2], digits=3), ", i18n(" with "), ", min.VSS2, ", i18n(" factors."), ", sep=\"\"))\n\n"
  ),
  rk.JS.header("Minimum Average Partial", level=4),
  echo(
    "rk.print(paste(", i18n("The Velicer MAP criterion achieves a minimum of "), ", round(VSS.data[[\"map\"]][min.MAP], digits=3), ", i18n(" with "), ", min.MAP, ", i18n(" factors."), ", sep=\"\"))\n\n"
  ),
  rk.JS.header("Statistics", level=4),
  echo("rk.results(vss.stat.results)\n\n")
)

## make a whole component
vss.component <- rk.plugin.component("Very Simple Structure/Minimum Average Partial",
  xml=list(
    logic=vss.lgc.sect,
    dialog=vss.full.dialog),
  js=list(
    require="psych",
    calculate=vss.js.calc,
    printout=vss.js.print),
  guess.getter=guess.getter,
  hierarchy=list("analysis", "Factor analysis","Number of factors"),
  create=c("xml", "js"))


############
## correlation plot
############
crpltData <- rk.XML.varselector(label="Select data", id.name="crpltData")
crpltDataSelected <- rk.XML.varslot(label="Data (correlation/factor matrix)",
  source=crpltData,
#  classes=c("data.frame", "matrix"),
  required=TRUE,
  id.name="crpltDataSelected")

crpltMainTitle <- rk.XML.input(label="Main title", initial="Correlation plot", id.name="crpltMainTitle")

colors <- rk.XML.radio(label="Colors",
  options=list(
    "Red to Blue"=c(val="true", chk=TRUE),
    "Greyscale"=c(val="false")
  ),
  id.name="colors"
)
numShades <- rk.XML.spinbox(label="Number of shades", min=2, initial=51, real=FALSE, id.name="numShades")

spinLower <- rk.XML.spinbox(label="from", min=-1, max=1, initial=-1, id.name="spinLower")
spinUpper <- rk.XML.spinbox(label="to", min=-1, max=1, initial=1, id.name="spinUpper")
rangeToColor <- rk.XML.frame(
  rk.XML.row(
    rk.XML.col(
      spinLower,
      id.name="clmSpnbxlower"
    ),
    rk.XML.col(
      spinUpper,
      id.name="clmSpnbxupper"
    )
  ),
  label="Range of correlation values to color",
  id.name="rangeToColor"
)

numCat <- rk.XML.spinbox(label="Number of categories in legend", min=1, initial=10, real=FALSE, id.name="numCat")

crplt.preview <- rk.XML.preview()

crplt.full.dialog <- rk.XML.dialog(
  rk.XML.row(
    crpltData,
    rk.XML.col(
      crpltDataSelected,
      colors,
      rangeToColor,
      numShades,
      rk.XML.stretch(),
      crpltMainTitle,
      crpltShowLegend <- rk.XML.frame(
        numCat,
        checkable=TRUE,
        chk=TRUE,
        label="Show legend",
        id.name="crpltShowLegend"),
      crplt.preview
    )
  ),
  label="Correlation plot")

## JavaScript
crplt.js.print <- rk.paste.JS(
  js.chk.lables <- rk.JS.vars(crpltShowLegend, modifiers="checked"),
  rk.paste.JS.graph(
    echo("\t\tcor.plot("),
    js(
      if(crpltDataSelected){
        echo("\n\t\t\tr=", crpltDataSelected)
      } else {},
      if(colors == "false"){
        echo(",\n\t\t\tcolors=FALSE")
      } else {},
      if(numShades != 51){
        echo(",\n\t\t\tn=",numShades)
      } else {},
      if(crpltMainTitle != "Correlation plot"){
        echo(",\n\t\t\tmain=\"", crpltMainTitle, "\"")
      } else {},
      if(spinLower != id(-1) || spinUpper != 1){
        echo(",\n\t\t\tzlim=c(",spinLower,",",spinUpper, ")")
      } else {},
      if(js.chk.lables){
        if(numCat != 10){
          echo(",\n\t\t\tn.legend=", numCat)
        } else {}
      } else {
        echo(",\n\t\t\tshow.legend=FALSE")
      }
    ),
    echo("\n\t\t)")
  )
)

## make a whole component
crplt.component <- rk.plugin.component("Correlation plot",
  xml=list(
    dialog=crplt.full.dialog),
  js=list(results.header="Correlation plot",
    require="psych",
     printout=crplt.js.print),
  guess.getter=guess.getter,
  hierarchy=list("plots", "Factor analysis"),
  create=c("xml", "js"))


#############
## if you run the following function call, files will be written to tempdir!
#############
# this is where it get's serious, that is, here all of the above is put together into one plugin

rk.FactorAnalysis.dir <<- rk.plugin.skeleton(
  about.info,
  path=output.dir,
  guess.getter=guess.getter,
  xml=list(
    logic=lgc.sect,
    dialog=full.dialog),
  js=list(
    globals="var isObrot;",
    results.header=FALSE,
    require="psych",
    calculate=js.calc,
    printout=js.print),
  pluginmap=list(name="Factor analysis", hierarchy=list("analysis", "Factor analysis")),
  components=list(
    scree.component,
    crplt.component,
    prll.component,
    vss.component),
  dependencies=dependencies.info,
  create=c("pmap", "xml", "js", "desc"),
  overwrite=overwrite,
  tests=FALSE,
#  edit=TRUE,
#  show=TRUE,
  load=TRUE,
  hints=FALSE)

  if(isTRUE(update.translations)){
    rk.updatePluginMessages(file.path(output.dir,"rk.FactorAnalysis","inst","rkward","rk.FactorAnalysis.pluginmap"))
  } else {}
})
